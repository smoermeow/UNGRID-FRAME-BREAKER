import { GoogleGenAI, Type } from "@google/genai";
import { Resolution, AspectRatio, ProcessingMode, BoundingBox, FixType } from '../types';

const KEY_STORAGE_NAME = 'ungrid_user_api_key';

export const getStoredApiKey = () => localStorage.getItem(KEY_STORAGE_NAME);
export const setStoredApiKey = (key: string) => localStorage.setItem(KEY_STORAGE_NAME, key);
export const clearStoredApiKey = () => localStorage.removeItem(KEY_STORAGE_NAME);

export const hasValidKey = () => {
  return !!getStoredApiKey() || !!process.env.API_KEY;
};

const getClient = () => {
  // Prioritize manually entered local keys to ensure BYOK behavior
  const apiKey = getStoredApiKey() || process.env.API_KEY;
  if (!apiKey) throw new Error("MISSING_API_KEY");
  return new GoogleGenAI({ apiKey });
};

export const detectPanels = async (base64Image: string): Promise<BoundingBox[]> => {
  const data = base64Image.split(',')[1] || base64Image;
  try {
    const ai = getClient();
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: {
        parts: [
          { inlineData: { mimeType: 'image/png', data } },
          { text: "Detect the bounding boxes of all distinct panels in this image. Return a JSON object with a 'panels' array containing objects with 'ymin', 'xmin', 'ymax', 'xmax' where the values are integers from 0 to 1000 representing the relative position." }
        ]
      },
      config: {
        responseMimeType: 'application/json',
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            panels: {
              type: Type.ARRAY,
              items: {
                type: Type.OBJECT,
                properties: {
                  ymin: { type: Type.INTEGER },
                  xmin: { type: Type.INTEGER },
                  ymax: { type: Type.INTEGER },
                  xmax: { type: Type.INTEGER },
                },
                required: ['ymin', 'xmin', 'ymax', 'xmax'],
              },
            },
          },
        },
      }
    });
    let text = response.text || '{}';
    text = text.replace(/^```json\s*/, '').replace(/```$/, '').trim();
    const json = JSON.parse(text);
    return json.panels || [];
  } catch (error) {
    console.error("Gemini Detect Panels Error:", error);
    throw error;
  }
};

export const reimagineImage = async (
  base64Image: string, 
  resolution: Resolution, 
  aspectRatio: AspectRatio, 
  mode: ProcessingMode
): Promise<string> => {
  const data = base64Image.split(',')[1] || base64Image;
  let prompt = mode === 'fidelity' 
    ? `Create a high-fidelity copy of this image. Preserve original colors and lighting. Resolution: ${resolution}.`
    : `Create a high-fidelity version. Maintain composition but enhance details and lighting. Resolution: ${resolution}.`;

  try {
    const ai = getClient();
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-image-preview',
      contents: [{ parts: [{ inlineData: { mimeType: 'image/png', data } }, { text: prompt }] }],
      config: { imageConfig: { imageSize: resolution, aspectRatio: aspectRatio } }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) return `data:image/png;base64,${part.inlineData.data}`;
    }
    throw new Error("No image generated by Gemini.");
  } catch (error: any) {
    console.error("Gemini Re-imagine Error:", error);
    throw error;
  }
};

export const fixDetail = async (
  targetBase64: string,
  referenceBase64: string,
  resolution: Resolution,
  fixType: FixType,
  positionContext: string = ""
): Promise<string> => {
  const targetData = targetBase64.split(',')[1] || targetBase64;
  const referenceData = referenceBase64.split(',')[1] || referenceBase64;
  const positionClause = positionContext.trim() ? ` (Context: ${positionContext.trim()})` : "";
  
  const prompt = `Image 1 (Target) and Image 2 (Reference) are the same character. Restore Image 1 to high quality using Image 2 features. Maintain pose exactly${positionClause}. Mode: ${fixType}.`;

  try {
    const ai = getClient();
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-image-preview',
      contents: [{ parts: [{ inlineData: { mimeType: 'image/png', data: targetData } }, { inlineData: { mimeType: 'image/png', data: referenceData } }, { text: prompt }] }],
      config: { imageConfig: { imageSize: resolution } }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) return `data:image/png;base64,${part.inlineData.data}`;
    }
    throw new Error("No image generated by Gemini.");
  } catch (error: any) {
    console.error("Gemini Detail Fix Error:", error);
    throw error;
  }
};

export const runChainCleaningStep = async (
  currentImageBase64: string,
  referenceImageBase64: string | null,
  instruction: string,
  resolution: Resolution
): Promise<string> => {
  const currentData = currentImageBase64.split(',')[1] || currentImageBase64;
  const parts: any[] = [{ inlineData: { mimeType: 'image/png', data: currentData } }];
  if (referenceImageBase64) parts.push({ inlineData: { mimeType: 'image/png', data: referenceImageBase64.split(',')[1] } });
  parts.push({ text: `Edit this image: ${instruction}. Maintain original composition.` });

  try {
    const ai = getClient();
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-image-preview',
      contents: [{ parts }],
      config: { imageConfig: { imageSize: resolution } }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) return `data:image/png;base64,${part.inlineData.data}`;
    }
    throw new Error("No image generated by Gemini.");
  } catch (error: any) {
    console.error("Gemini Chain Clean Error:", error);
    throw error;
  }
};